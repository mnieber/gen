# Moonleap code generator

Moonleap is a tool that automates part of the work that a programmer does. Programmers are able to read
a project specification and turn it into a set of source files. Based on the words that are
used in the project description, they are able to:

1. imagine the structure of the project
2. determine tools and software that need to be installed
3. create a minimal configuration for these tools
4. progressively fill in more details to make the system work as suggested

To what extent would a computer program be able to do this automatically? The proposition of Moonleap is
that - by using a clever and pragmatic approach - a useful skeleton project can be created from a specification
automatically. The key ideas behind this approach are:

- the spec is written in natural language, where important nouns with a colon and verbs with a slash,
  e.g. "the :project /has a backend:service". This makes for highly readable
  specs that are also easy to process programmatically.

- the code generator turns these nouns and verbs into a directed graph of resources.
  For every resource, code is generated by rendering text templates that have access to the information in
  that resource.

- the output is treated as a shadow project that serves as the starting point for the real project.
  Changes in the shadow can be copied to the real project using a diff/merge tool such as Meld. This way, the spec, the
  shadow and the real project evolve side by side. More importantly, it means that the shadow project does not have to be
  perfect, it only has to be useful.

- Moonleap is intended to be customized. A developer can introduce their own set of nouns and verbs, and add rules and
  templates that turn these into first resources and then source code.

## Scope

How much can be accomplished with this approach? This is hard to answer exactly, but probably quite a lot.
Just based on knowing the fields in a datatype we can create:

- an ORM model / database table
- a graphql interface (including the skeleton for a test)
- a typescript type, frontend api endpoint and data store
- a list-view with corresponding item view
- a form view, including field validation and skeleton end-to-end test

Also, considering that operations such as selection, filtering and drag-and-drop can operate on lists of ids,
we can create code for list-views that support these operations. It's important though that the generated code
looks very similar to hand-written code, otherwise it cannot serve as the basis for a nice code base.

## Running

```
pip install requirements.txt
python moonleap.py --spec=specs/titan.md gen
python moonleap.py --spec=specs/titan.md diff
```

## A short example

To explain how this works, consider this spec

```
## The backend:service

The backend:service /uses a python_3.8:docker-image. :It /uses :pytest.
```

A developer can add a rule for turning "backend:service" into a resource:

```
@dataclass
class Service:
    name: str

@tags(["service"])
def create_service(term, block):
    return Service(name=term.data)

@rule("service", "uses", "pytest")
def service_uses_pytest(service, pytest):
    # Here, you can add additional steps that use
    # the service and pytest resource objects
    pass
```

The developer can then configure the set of the templates that take this resource as input:

```
@extend(Service)
class ExtendService:
    render = MemFun(render_templates(__file__), "templates")
```

Moonleap turns the spec into a set of source files as follows:

1. Each term is converted into one or more resources, e.g. for backend:service we create`Service("backend")`,
   for python_3.8:dockerimage we create `DockerImage("python_3.8")` and for :pytest we create a `Pytest()` resource
   that points to a `PipDependency("pytest")` resource (note that the example only shows the rule to create the
   service resource).

2. :It is an alias that resolves to the first term in the preceeding sentence. In the example that
   would be "backend:service".

3. Resources are rendered into artifacts. The rendering process uses the graph-structure that connects all
   the resources. In our example we can set up the rendering rules such that the pytest pip package is installed inside the Dockerfile
   (based on the `PipDependency("pytest")` and `Dockerfile("python_3.8")` resources in the graph).
